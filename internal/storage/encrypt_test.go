package storage

import (
	"crypto/rand"
	"encoding/hex"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestEncryptDecryptRoundTrip(t *testing.T) {
	dir := t.TempDir()
	enc, err := NewEncryptor(dir)
	if err != nil {
		t.Fatalf("NewEncryptor: %v", err)
	}

	original := "sk-test-1234567890abcdef"
	encrypted, err := enc.Encrypt(original)
	if err != nil {
		t.Fatalf("Encrypt: %v", err)
	}

	if !strings.HasPrefix(encrypted, encPrefix) {
		t.Fatalf("encrypted value should start with %q, got %q", encPrefix, encrypted)
	}
	if encrypted == original {
		t.Fatal("encrypted value should differ from original")
	}

	decrypted, err := enc.Decrypt(encrypted)
	if err != nil {
		t.Fatalf("Decrypt: %v", err)
	}
	if decrypted != original {
		t.Fatalf("round-trip failed: got %q, want %q", decrypted, original)
	}
}

func TestLegacyPlaintextPassthrough(t *testing.T) {
	dir := t.TempDir()
	enc, err := NewEncryptor(dir)
	if err != nil {
		t.Fatalf("NewEncryptor: %v", err)
	}

	plain := "sk-plaintext-key-no-prefix"
	result, err := enc.Decrypt(plain)
	if err != nil {
		t.Fatalf("Decrypt plaintext: %v", err)
	}
	if result != plain {
		t.Fatalf("plaintext passthrough failed: got %q, want %q", result, plain)
	}
}

func TestNilEncryptorPassthrough(t *testing.T) {
	var enc *Encryptor

	val := "some-api-key"
	encrypted, err := enc.Encrypt(val)
	if err != nil {
		t.Fatalf("nil Encrypt: %v", err)
	}
	if encrypted != val {
		t.Fatalf("nil Encrypt should passthrough: got %q", encrypted)
	}

	decrypted, err := enc.Decrypt(val)
	if err != nil {
		t.Fatalf("nil Decrypt: %v", err)
	}
	if decrypted != val {
		t.Fatalf("nil Decrypt should passthrough: got %q", decrypted)
	}

	// Ptr variants
	ptr := &val
	encPtr, err := enc.EncryptPtr(ptr)
	if err != nil {
		t.Fatalf("nil EncryptPtr: %v", err)
	}
	if encPtr != ptr {
		t.Fatal("nil EncryptPtr should return same pointer")
	}

	decPtr, err := enc.DecryptPtr(ptr)
	if err != nil {
		t.Fatalf("nil DecryptPtr: %v", err)
	}
	if decPtr != ptr {
		t.Fatal("nil DecryptPtr should return same pointer")
	}

	// Nil pointer
	encNil, err := enc.EncryptPtr(nil)
	if err != nil {
		t.Fatalf("nil EncryptPtr(nil): %v", err)
	}
	if encNil != nil {
		t.Fatal("nil EncryptPtr(nil) should return nil")
	}
}

func TestAutoGeneratedKeyFile(t *testing.T) {
	dir := t.TempDir()
	_, err := NewEncryptor(dir)
	if err != nil {
		t.Fatalf("NewEncryptor: %v", err)
	}

	keyPath := filepath.Join(dir, keyFileName)
	info, err := os.Stat(keyPath)
	if err != nil {
		t.Fatalf("key file not created: %v", err)
	}

	if perm := info.Mode().Perm(); perm != 0600 {
		t.Fatalf("key file permissions: got %o, want 0600", perm)
	}

	// Creating a second encryptor from the same dir should reuse the key.
	enc2, err := NewEncryptor(dir)
	if err != nil {
		t.Fatalf("second NewEncryptor: %v", err)
	}

	// Verify they produce compatible ciphertext.
	enc1, _ := NewEncryptor(dir)
	ct, err := enc1.Encrypt("test-value")
	if err != nil {
		t.Fatalf("Encrypt: %v", err)
	}
	pt, err := enc2.Decrypt(ct)
	if err != nil {
		t.Fatalf("Decrypt with second encryptor: %v", err)
	}
	if pt != "test-value" {
		t.Fatalf("cross-encryptor round-trip failed: got %q", pt)
	}
}

func TestWrongKeyFailsDecrypt(t *testing.T) {
	dir1 := t.TempDir()
	dir2 := t.TempDir()

	enc1, err := NewEncryptor(dir1)
	if err != nil {
		t.Fatalf("NewEncryptor 1: %v", err)
	}
	enc2, err := NewEncryptor(dir2)
	if err != nil {
		t.Fatalf("NewEncryptor 2: %v", err)
	}

	ct, err := enc1.Encrypt("secret")
	if err != nil {
		t.Fatalf("Encrypt: %v", err)
	}

	_, err = enc2.Decrypt(ct)
	if err == nil {
		t.Fatal("Decrypt with wrong key should fail")
	}
}

func TestEnvVarOverride(t *testing.T) {
	key := make([]byte, keySize)
	if _, err := rand.Read(key); err != nil {
		t.Fatal(err)
	}
	hexKey := hex.EncodeToString(key)

	t.Setenv("CLICKNEST_ENCRYPTION_KEY", hexKey)

	dir := t.TempDir()
	enc, err := NewEncryptor(dir)
	if err != nil {
		t.Fatalf("NewEncryptor with env var: %v", err)
	}

	// Key file should NOT be created when env var is used.
	keyPath := filepath.Join(dir, keyFileName)
	if _, err := os.Stat(keyPath); !os.IsNotExist(err) {
		t.Fatal("key file should not be created when env var is set")
	}

	// Round-trip should work.
	ct, err := enc.Encrypt("env-secret")
	if err != nil {
		t.Fatalf("Encrypt: %v", err)
	}
	pt, err := enc.Decrypt(ct)
	if err != nil {
		t.Fatalf("Decrypt: %v", err)
	}
	if pt != "env-secret" {
		t.Fatalf("got %q, want %q", pt, "env-secret")
	}
}

func TestPtrRoundTrip(t *testing.T) {
	dir := t.TempDir()
	enc, err := NewEncryptor(dir)
	if err != nil {
		t.Fatalf("NewEncryptor: %v", err)
	}

	original := "my-secret-key"
	encrypted, err := enc.EncryptPtr(&original)
	if err != nil {
		t.Fatalf("EncryptPtr: %v", err)
	}
	if encrypted == nil {
		t.Fatal("EncryptPtr returned nil")
	}
	if !strings.HasPrefix(*encrypted, encPrefix) {
		t.Fatalf("encrypted ptr should have prefix, got %q", *encrypted)
	}

	decrypted, err := enc.DecryptPtr(encrypted)
	if err != nil {
		t.Fatalf("DecryptPtr: %v", err)
	}
	if *decrypted != original {
		t.Fatalf("ptr round-trip: got %q, want %q", *decrypted, original)
	}
}
